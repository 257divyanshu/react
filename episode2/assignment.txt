# Theory Assignment:
‚óè - What is `NPM`?
‚óè - What is `Parcel/Webpack`? Why do we need it?
‚óè - What is `.parcel-cache`
‚óè - What is `npx` ?
‚óè - What is difference between `dependencies` vs `devDependencies`
‚óè - What is Tree Shaking?
‚óè - What is Hot Module Replacement?
‚óè - List down your favourite 5 superpowers of Parcel and describe any 3 of them in your
own words.
‚óè - What is `.gitignore`? What should we add and not add into it?
‚óè - What is the difference between `package.json` and `package-lock.json` 
‚óè - Why should I not modify `package-lock.json`? 
‚óè - What is `node_modules` ? Is it a good idea to push that on git?
‚óè - What is the `dist` folder?
‚óè - What is `browserlists` üü•

Read about dif bundlers: vite, webpack, parcel
‚óè Read about: ^ - caret and ~ - tilda üü•
‚óè Read about Script types in html (MDN Docs) üü•

# References
‚óè Creating your own create-react-app
‚óè Parcel Documentation
‚óè Parcel on Production
‚óè BrowsersList: https://browserslist.dev/

‚óè NPM
- It is a package manager for the JavaScript programming language and the Node.js runtime environment
- used for package and dependency management
- npm registry : online repo where all the packages are published 
- allows developers to define scripts in the package.json file which helps automate tasks like running tests, building projects, starting servers
- npm is usually installed with the node js

‚óè BUNDLERS
- is a tool that takes multiple modules (files) and combines them into a single file, or a few optimized files, for use in a web application.
- purpose : code organization , dependency management , performance optimization (reduce the number of HTTP requests the browsers needs to make)
- used in building SPAs and complex web applications

‚óè .PARCEL-CACHE DIRECTORY
- is cache diretory 
- stores intermediate build artifacts and cached assets from previous builds
- This allows Parcel to reuse these cached files in subsequent builds, significantly speeding up the build process.
- benefits : 
  - reduces redundant computations
  - speeds up build process

‚óè NPX
- stands for node package execute
- It allows you to run packages from the npm registry or your project's dependencies without having to install them globally
- the order of checking goes like : check local , if not found got to global, if not found go to cache, if not found download the pacakge from npm registry into the cache folder, is that right  

‚óè DEVDEPENDENCY v/s NORMAL DEPENDENCY
- devdependencies are used in the development phase (command : npx install -d depName)
- normal dependencies are used in the production phase (command : npx install depName)
- normal dependencies are required for running the application
- devdependencies are required for testing, linting, code formatting and buidling your application
- normal dependencies are a part of the production bundle but devdependencies are not 

‚óè GITIGNORE FILE
- is used to define a list of files and directories that should be ignored by Git. 
- is usually placed in the root directory of the git repository
- Changes to the .gitignore file itself can be tracked by Git and committed to the repository, allowing other developers to use the same ignoring rules.

‚óè NODE_MODULES FOLDER
- It contains all the packages and dependencies specified in your project's package.json file.
- is created automatically by npm when we install packages in our project
- each package contains its own package.json file
- it is managed by npm, which means you generally do not need to manually modify it.
- using npm commands like npm install, npm update, npm uninstall will automatically adjust the contents of the node_modules folder accordingly.
- Packages can have multiple versions installed in the node_modules folder if different dependencies require different versions of the same package.


‚óè DIST FOLDER
- dist stands for distribution
- It can include minified JavaScript and CSS files, optimized images, and other asset 
- is created during the build proecess
- contains : minified and bundled JS and CSS files , optimized images and assets , HTML files , source maps for debugging
- is where we point our server to serve the final version of our application when deploying it.

‚óè PACKAGE.JSON v/s PACKAGE-LOCK.JSON 
- .json Manages project configuration and specifies metadata, dependencies, scripts, and other settings.
- lock.json Locks down the exact versions of dependencies and sub-dependencies for consistent installations.
- .json Specifies dependencies and their version ranges
- lock.json Lists the exact versions and locations of all dependencies and sub-dependencies installed.
- .json is Intended to be human-readable and editable by developers.
- lock.json is Automatically generated by npm and should not be manually edited.
- .json is Used by npm as a reference for installing dependencies according to specified version ranges.
- lock.json Ensures consistent installations by locking dependencies to specific versions.
- .json Provides the basic dependency ranges, which can lead to different installations depending on when and where it's installed.
- lock.json Guarantees consistent and reproducible builds across different environments.

---------------------------------------------------------------------------------------------

‚óè BTS OF BUNDLING
- scanning : Bundlers scan your source files and identify the modules and their dependencies
- bundling :  The modules and their dependencies are combined into one or more bundles according to the project's configuration.
- optimization :  During bundling, optimizations such as minification, tree shaking, and code splitting may be applied.
- output : The final bundles are generated

‚óè CODE SPLITTING
- it involves breaking up your code into smaller chunks, so that only the necessary code is loaded at any given time
- benefits : 
  - faster load time : as the amount of code to be loaded initially has been reduced
  - improves user experience : application will be more repsonsive and feel faster to the user
  - reduces bandwidth usage : Loading only the necessary code can save bandwidth for both the user and the server. 
- types of code splitting
  - entry point splitting :  Splitting your code based on different entry points in your application. For example, different routes or pages in a single-page application.
  - Component Splitting: Splitting your code based on different components in a UI library such as React. This way, each component can be loaded as needed.
  - Library Splitting: Splitting your code by libraries or dependencies. This allows you to load only the necessary libraries when they are needed.
- challenges : 
  - Complexity: it adds complexity to the codebase, especially when dealing with dynamic imports and lazy loading.
  - testing : Testing code-split applications are more challenging, as different parts of the application may not be loaded at the same time.
  - caching : Ensuring proper caching strategies for dynamically loaded code can be more complex.

‚óè TREE SHAKING
- removes the unused code from the codebase
- bts : 
  - static anylysis and identification of imports and exports 
  - usage analysis : checks which exports are being used and which are not using the import 
  - unused code removal : unused code is removed from the final bundle 
- benefits : 
  - smaller bundle size (leads to faster load times)
  - improved performance (due to faster load times)
  - enhances maintainability (developers can clean up their codebase and focus on maintaining only the necessary code)
- Challenges : 
  - dynamic code : Tree shaking works best with static code analysis, if the application uses dynamic code (dynamic imports) implementing tree shaking becomes complex 
  - ES5 compatibility : tree shaking might not work effectively with older JavaScript syntax
  - library compatibility : tree shaking may depend on whether third party libraries are written with ES6 modules and whether they are designed for tree shaking or not

‚óè MINIFICATION 
- is a technique used in web development to optimize code for improved performance and efficiency. 
- bts : 
  - removes whitespaces, comments, line breaks and other non-essential characters
  - shortens identfiers
  - expressions are inlined
- benefits : 
  - smaller code size (takes up less space and can be transferred easily)
  - faster load times (because of smaller code)
- challenges : 
  - decreases readability
  - makes debugging harder

‚óè COMPRESSION
- is a technique used in web development to optimize code for improved performance and efficiency
- bts : 
  - uses compression algorithms like Gzip and Brotli which encode the code into compressed format
  - when the client receives thes compressed code, it decompresses it to executed the original code
- benefits : 
  - samller code size
  - faster load time
- challenges : 
  - compressing and decompressing adds some overhead (but the savings in data transfer outwiegh this)
  - the client and the server should support the chosen compression format (eg Gzip or Brotli)

‚óè LOADERS
- allow developers to preprocess files and transform their content before bundling them into the final application
- purpose : 
  - loaders transform files from different formats into a format that bundlers can handle 
  - enhances compatibility : allow developers to use modern and not standard file formats in their applications, even if the browser or runtime does not natively support it
- types : 
  - transpilation loaders : convert code from one language or syntax to another (like Babel )
  - CSS loaders : processes CSS files, allows us to import them as modules in our application and handle stylesheets more effectively
  - image loaders : optimize and transform images, such as resizing, compressing, converting them to different formats
  - file loaders : hadles other types of files, such as fonts and provides a way to import them into the application
  - custom loaders can also be created 
- flexibility
  - allows developers to work with wide variety of file types making development more flexible
  - performs optimizations such as minifications, compression and image optimization to improve performance 
- Challenges 
  - Managing multiple loaders and their configurations can add complexity to the build process.
  - Debugging issues related to loaders can be challenging because the transformation process can obscure the original code.

‚óè ASSET MANAGEMENT
- refers to the handling and optimizing of various types of assets, such as images, fonts, stylesheets (CSS), and other static files, to ensure they are efficiently integrated into the application.
- purpose : 
  - bundlers organize different types of assets within the project making them easier to manage and reference
  - bundlers optimize assets for faster load times and efficient use of resources
  - bundlers integrate assets into the application by converting them into modules and processesing them as needed
- types of assets that bundlers handle : fonts , stylesheets , images and other file formats
- bts : 
  - bundlers enable us to import assets directly into JavaScript modules using import statements
  - then bundlers optimizes those assets
  - bundlers then handle the output of processed assets by organizing them in the build directory according to their configuration
- benefits : 
  - reduces the overall file size
  - eases the integration and management of assets
- challenges : 
  - configuring asset management in bundles can be complex especially for projects with various types of assets and requirements
  - debugging asset related issues can be challenging

‚óè SOURCE MAPS
- provided by bundlers
- are files that provide a mapping between the transformed or minified code and the original source code
- purpose : 
  - improves debugging : Source maps help developers debug the application by mapping errors and stack traces back to the original source code.
  - maintains readability : When code is minified or transformed, it can become difficult to read and understand. Source maps preserve the original code structure for easier maintenance and debugging.
  - bridges the gap : Source maps create a bridge between the original source code and the processed code, making it possible to trace issues back to the original code.
- benefits : 
  - improves debugging as developers can use source maps to understand error messages and stack traces in the context of the original code
- challenges : 
  - Generating source maps can add some overhead to the build process, though this is often a small trade-off compared to the benefits.

‚óè HOT MODULE REPLACEMENT
- that allows modules in an application to be updated in real time without requiring a full page reload. 
- purpose : 
  - improves development workflow 
  - preserves the application state (even when a module is updated) (application state : when a part of the application code is updated and replaced, the rest of the application remains as it is, including any data and user interactions that were in progress.)
- bts : 
  - when a file is modified, the bundler detects the change and recompiles the affected module
  - the bundler then sends the updated module to the applicaton running in the browser
  - the old module is replaced with the new updated module without a full page reload
- benefits :
  - instant feedback 
  - improves productivity
  - maintains the application state
- challenges :
  - some modules or libraries may not support HMR
  - 

‚óè DIFFERENTIAL BUNDLING
- is a technique used by modern bundlers, such as Parcel, to create multiple versions of the same application bundle optimized for different environments or browsers
- purpose : 
  - optimized bundlers for different environments : (allows developers to create optimized bundles for specific environments or browsers, such as modern browsers that support ES6 or older browsers that require ES5)
  - improves performance : (By creating smaller, more targeted bundles, differential bundling can improve application load times and overall performance.)
  - Enhance Compatibility: Differential bundling ensures that applications can run smoothly on a wide range of devices and browsers, including older or less capable ones.
- benefits : 
  - smaller bundle size (as the bundles generated are targeted bundles)
  - ensures browser comp
  - improves the use experience (as load times are decreased)
- challenges : 
  - complex configuration
  - maintenance issues (as additional complexity has been added to the build process)
- moder browser require ES6, older browsers require ES5

‚óè FILE WATCHING ALGORITHM
- file watching algorithm is used to monitor changes in the file system while the application is running in development mode. This allows Parcel to automatically rebuild the application and reload the page when changes are detected, providing developers with a fast feedback loop and a smoother development experience.
- purpose : 
  - monitor file changes
  - trigger rebuilds
  - provide faster feedback
- starts when we run the command : npx parcel index.html
- ends when we terminate the build using Ctrl + C


‚óè
‚óè
‚óè
‚óè
‚óè
‚óè
‚óè
‚óè
‚óè
‚óè

‚óè NPM COMMANDS
‚óè LOCAL v/s GLOBAL PACKAGES
‚óè COMPRESSION ALGORITHMS (TYPES: LOSELESS AND )
‚óè DYNAMIC IMPORTS